---
import Pagination from "@components/control/Pagination.astro";
import PostPage from "@components/PostPage.astro";
import TaxonomyHeader from "@components/TaxonomyHeader.astro";
import { PAGE_SIZE } from "@constants/constants";
import I18nKey from "@i18n/i18nKey";
import { i18n } from "@i18n/translation";
import MainGridLayout from "@layouts/MainGridLayout.astro";
import type { CategoryNode } from "@utils/category-taxonomy-utils";
import {
	aggregateCounts,
	buildLeafLabelMap,
	findNodeBySlugPath,
	flattenSlugPathsWithPrefixes,
	getChildrenBySlugPath,
	pruneTaxonomyToDepth,
	resolvePostCategorySlugPath,
} from "@utils/category-taxonomy-utils";
import { getSortedPosts } from "@utils/content-utils";
import { UNCATEGORIZED_SLUG } from "@utils/taxonomy-utils";
import { getCategorySlugPathUrl } from "@utils/url-utils";
import type { GetStaticPaths } from "astro";
import taxonomy from "@/data/category-taxonomy.json";

const MAX_DEPTH = 2;

const resolveSlugPathFromParams = (path: string | undefined) => {
	const segments = (path ?? "")
		.split("/")
		.map((seg) => seg.trim())
		.filter((seg) => seg !== "");
	const lastSegment = segments.at(-1);
	const pageNumber =
		lastSegment && /^\d+$/.test(lastSegment) ? Number(segments.pop()) : 1;
	if (segments.length > MAX_DEPTH) {
		throw new Error(
			`Category path exceeds maximum depth of ${MAX_DEPTH}: ${segments.join(" / ")}`,
		);
	}
	return { slugPath: segments, pageNumber };
};

export const getStaticPaths = (async () => {
	const taxonomyData = pruneTaxonomyToDepth(taxonomy as CategoryNode[]);
	const leafLabelMap = buildLeafLabelMap(taxonomyData);
	const allPosts = await getSortedPosts();

	const leafCounts = new Map<string, number>();
	allPosts.forEach((post) => {
		const slugPath = resolvePostCategorySlugPath(post.data, taxonomyData, {
			leafLabelMap,
		});
		const key = slugPath.join("/");
		leafCounts.set(key, (leafCounts.get(key) ?? 0) + 1);
	});

	const slugPathSet = new Set<string>();
	for (const path of flattenSlugPathsWithPrefixes(taxonomyData)) {
		slugPathSet.add(path.join("/"));
	}
	allPosts.forEach((post) => {
		const slugPath = resolvePostCategorySlugPath(post.data, taxonomyData, {
			leafLabelMap,
		});
		slugPathSet.add(slugPath.join("/"));
	});

	const leafCountsObj = Object.fromEntries(leafCounts);

	const pathEntries = Array.from(slugPathSet)
		.map((pathStr) => pathStr.split("/"))
		.flatMap((slugPath) => {
			const node = findNodeBySlugPath(slugPath, taxonomyData)?.node;
			const isLeaf = !node || !node.children?.length;
			const countKey = slugPath.join("/");
			const totalForLeaf = leafCountsObj[countKey] ?? 0;
			const totalPages = isLeaf
				? Math.max(1, Math.ceil(totalForLeaf / PAGE_SIZE))
				: 1;

			return Array.from({ length: totalPages }, (_, index) => {
				const pageNumber = index + 1;
				const pageSuffix = pageNumber > 1 ? `/${pageNumber}` : "";
				return { params: { path: `${slugPath.join("/")}${pageSuffix}` } };
			});
		});

	return pathEntries;
}) satisfies GetStaticPaths;

const { slugPath, pageNumber } = resolveSlugPathFromParams(Astro.params.path);
const taxonomyData = pruneTaxonomyToDepth(taxonomy as CategoryNode[]);
const leafLabelMap = buildLeafLabelMap(taxonomyData);
const nodeMatch = findNodeBySlugPath(slugPath, taxonomyData);
const children = getChildrenBySlugPath(slugPath, taxonomyData);
const isLeaf = !nodeMatch?.node || !nodeMatch.node.children?.length;
const labelPath =
	nodeMatch?.labelPath ??
	(slugPath[0] === UNCATEGORIZED_SLUG && slugPath.length === 1
		? [i18n(I18nKey.uncategorized)]
		: slugPath);
const title = labelPath.at(-1) ?? i18n(I18nKey.uncategorized);

const allPosts = await getSortedPosts();
const leafCounts = new Map<string, number>();
allPosts.forEach((post) => {
	const resolved = resolvePostCategorySlugPath(post.data, taxonomyData, {
		leafLabelMap,
	});
	const key = resolved.join("/");
	leafCounts.set(key, (leafCounts.get(key) ?? 0) + 1);
});
const aggregateCountMap = aggregateCounts(leafCounts, taxonomyData);
const currentKey = slugPath.join("/");
const totalForLeaf = leafCounts.get(currentKey) ?? 0;
const displayCount = isLeaf
	? totalForLeaf
	: (aggregateCountMap.get(currentKey) ?? 0);

const postsForCurrent = isLeaf
	? allPosts.filter((post) => {
			const resolved = resolvePostCategorySlugPath(post.data, taxonomyData, {
				leafLabelMap,
			});
			return resolved.join("/") === currentKey;
		})
	: [];

const total = postsForCurrent.length;
const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
const currentPage = Math.min(Math.max(pageNumber, 1), totalPages);
const start = (currentPage - 1) * PAGE_SIZE;
const end = start + PAGE_SIZE;
const pageData = postsForCurrent.slice(start, end);

const page = isLeaf
	? {
			data: pageData,
			start,
			end: Math.min(end, total),
			size: PAGE_SIZE,
			total,
			currentPage,
			lastPage: totalPages,
			url: {
				current: getCategorySlugPathUrl(slugPath, currentPage),
				first: getCategorySlugPathUrl(slugPath, 1),
				last: getCategorySlugPathUrl(slugPath, totalPages),
				prev:
					currentPage > 1
						? getCategorySlugPathUrl(slugPath, currentPage - 1)
						: undefined,
				next:
					currentPage < totalPages
						? getCategorySlugPathUrl(slugPath, currentPage + 1)
						: undefined,
			},
		}
	: null;
---

<MainGridLayout title={title}>
	<TaxonomyHeader
		title={title}
		count={displayCount}
		currentPage={page?.currentPage}
		lastPage={page?.lastPage}
		breadcrumb={labelPath.join(" / ")}
	/>

	{children.length > 0 && nodeMatch?.node && (
		<nav class="flex flex-wrap gap-2 mb-6">
			{children.map((child) => (
				<a
					href={getCategorySlugPathUrl([...slugPath, child.slug])}
					class="btn-card px-3 py-2 text-sm"
				>
					{child.label}
				</a>
			))}
		</nav>
	)}

	{page && (
		<>
			<PostPage page={page} />
			<Pagination
				class="mx-auto onload-animation"
				page={page}
				style={`animation-delay: calc(var(--content-delay) + ${page.data.length * 50}ms)`}
			/>
		</>
	)}
</MainGridLayout>
