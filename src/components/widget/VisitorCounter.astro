---
import { Icon } from "astro-icon/components";
import I18nKey from "../../i18n/i18nKey";
import { i18n, i18nFormat } from "../../i18n/translation";
import WidgetLayout from "./WidgetLayout.astro";

interface Props {
	class?: string;
	style?: string;

	/**
	 * 기본값: 1 (대부분 "오늘"로 고정)
	 * 필요하면 호출부(.astro)에서 <VisitorCounter rangeDays={7} /> 처럼 변경
	 */
	rangeDays?: number;
}

const className = Astro.props.class;
const style = Astro.props.style;

const provider = import.meta.env.PUBLIC_ANALYTICS_PROVIDER?.toLowerCase();

// ✅ .env에서 빼고 여기서 기본값을 고정합니다.
const DEFAULT_RANGE_DAYS = 1;
const parsedRange = Number(Astro.props.rangeDays ?? DEFAULT_RANGE_DAYS);
const rangeDays =
	Number.isFinite(parsedRange) && parsedRange > 0
		? parsedRange
		: DEFAULT_RANGE_DAYS;

// Umami via Worker stats endpoint
const umamiStatsUrl = import.meta.env.PUBLIC_UMAMI_STATS_URL?.replace(
	/\/$/,
	"",
);

// GoatCounter (optional)
const goatcounterBaseUrl =
	import.meta.env.PUBLIC_GOATCOUNTER_HOST?.replace(/\/$/, "") ||
	(import.meta.env.PUBLIC_GOATCOUNTER_CODE
		? `https://${import.meta.env.PUBLIC_GOATCOUNTER_CODE}.goatcounter.com`
		: undefined);
const goatcounterPath = import.meta.env.PUBLIC_GOATCOUNTER_PATH || "/";

const isUmami = provider === "umami" && Boolean(umamiStatsUrl);
const isGoatcounter = provider === "goatcounter" && Boolean(goatcounterBaseUrl);
const isConfigured = Boolean(isUmami || isGoatcounter);

const activeProvider = isUmami
	? "umami"
	: isGoatcounter
		? "goatcounter"
		: "none";
const providerLabel = isUmami
	? "Umami"
	: isGoatcounter
		? "GoatCounter"
		: i18n(I18nKey.visitorCounterNotConfigured);

// days=1이면 "오늘", 그 외는 "최근 N일"
const recentLabel = isUmami
	? rangeDays === 1
		? i18n(I18nKey.visitorCounterToday)
		: i18nFormat(I18nKey.visitorCounterRecent, { days: rangeDays })
	: isGoatcounter
		? i18n(I18nKey.visitorCounterToday)
		: i18nFormat(I18nKey.visitorCounterRecent, { days: rangeDays });

const totalLabel = i18n(I18nKey.visitorCounterTotal);
const initialStatus = isConfigured
	? i18n(I18nKey.visitorCounterLoading)
	: i18n(I18nKey.visitorCounterNotConfigured);
---

<WidgetLayout
	name={i18n(I18nKey.visitorCounter)}
	id="visitor-counter"
	class={className}
	style={style}
>
	<div
		class="flex flex-col gap-3 px-1"
		data-visitor-counter
		data-provider={activeProvider}
		data-umami-stats-url={umamiStatsUrl}
		data-goatcounter-base={goatcounterBaseUrl}
		data-goatcounter-path={goatcounterPath}
		data-range-days={String(rangeDays)}
		data-status-loading={i18n(I18nKey.visitorCounterLoading)}
		data-status-unavailable={i18n(I18nKey.visitorCounterUnavailable)}
		data-status-not-configured={i18n(I18nKey.visitorCounterNotConfigured)}
	>
		<div class="flex items-start justify-between gap-3">
			<div class="flex flex-col gap-1">
				<div class="flex items-center gap-2 text-sm font-semibold text-neutral-700 dark:text-neutral-200">
					<Icon
						name="material-symbols:analytics-outline-rounded"
						class="text-xl text-[var(--primary)]"
					/>
					<span>{i18nFormat(I18nKey.visitorCounterProvider, { provider: providerLabel })}</span>
				</div>
				<div class="text-xs text-neutral-500 dark:text-neutral-400" data-status aria-live="polite">{initialStatus}</div>
			</div>
		</div>

		<div class="grid grid-cols-2 gap-3">
			<div class="flex flex-col gap-1 p-3 rounded-xl bg-[var(--panel-bg,rgba(0,0,0,0.04))] dark:bg-white/5 border border-black/5 dark:border-white/5">
				<div class="text-[0.8rem] text-neutral-500 dark:text-neutral-400">{recentLabel}</div>
				<div class="text-3xl font-bold text-neutral-900 dark:text-neutral-50 leading-tight" data-count-recent aria-live="polite">—</div>
			</div>
			<div class="flex flex-col gap-1 p-3 rounded-xl bg-[var(--panel-bg,rgba(0,0,0,0.04))] dark:bg-white/5 border border-black/5 dark:border-white/5">
				<div class="text-[0.8rem] text-neutral-500 dark:text-neutral-400">{totalLabel}</div>
				<div class="text-3xl font-bold text-neutral-900 dark:text-neutral-50 leading-tight" data-count-total aria-live="polite">—</div>
			</div>
		</div>
	</div>
</WidgetLayout>

<script>
	(() => {
		const root = document.querySelector("[data-visitor-counter]") as HTMLElement | null;
		if (!root) return;

		const countRecentEl = root.querySelector("[data-count-recent]") as HTMLElement | null;
		const countTotalEl = root.querySelector("[data-count-total]") as HTMLElement | null;
		const statusEl = root.querySelector("[data-status]") as HTMLElement | null;

		const statusLoading = root.dataset.statusLoading ?? "";
		const statusUnavailable = root.dataset.statusUnavailable ?? "";
		const statusNotConfigured = root.dataset.statusNotConfigured ?? "";

		const provider = (root.dataset.provider ?? "none") as "umami" | "goatcounter" | "none";

		const parsedRange = Number(root.dataset.rangeDays ?? "1");
		const rangeDays = Number.isFinite(parsedRange) && parsedRange > 0 ? parsedRange : 1;

		const umamiStatsUrl = root.dataset.umamiStatsUrl ?? "";

		const goatcounterBase = root.dataset.goatcounterBase ?? "";
		const goatcounterPath = root.dataset.goatcounterPath ?? "/";

		const formatter = new Intl.NumberFormat(document.documentElement.lang || "en", {
			maximumFractionDigits: 0,
		});

		const normalizeNumber = (value: unknown): number | null => {
			if (typeof value === "number" && Number.isFinite(value)) return value;
			if (typeof value === "string") {
				const trimmed = value.trim();
				if (!trimmed) return null;
				const parsed = Number(trimmed);
				return Number.isFinite(parsed) ? parsed : null;
			}
			return null;
		};

		const setCounts = (recent: number | null, total: number | null): void => {
			if (countRecentEl) {
				countRecentEl.textContent =
					typeof recent === "number" ? formatter.format(recent) : "—";
			}
			if (countTotalEl) {
				countTotalEl.textContent =
					typeof total === "number" ? formatter.format(total) : "—";
			}
		};

		const setStatus = (text: string): void => {
			if (!statusEl) return;
			statusEl.textContent = text;
		};

		// ===== GoatCounter helpers (optional) =====
		const formatKstDate = (date: Date): string => {
			const kstDate = new Date(date.toLocaleString("en-US", { timeZone: "Asia/Seoul" }));
			const year = kstDate.getFullYear();
			const month = String(kstDate.getMonth() + 1).padStart(2, "0");
			const day = String(kstDate.getDate()).padStart(2, "0");
			return `${year}-${month}-${day}`;
		};

		const addDaysYmd = (ymd: string, days: number): string => {
			const [y, m, d] = ymd.split("-").map((v: string) => Number(v));
			const dt = new Date(Date.UTC(y, m - 1, d));
			dt.setUTCDate(dt.getUTCDate() + days);
			return dt.toISOString().slice(0, 10);
		};

		const buildGoatcounterUrl = (
			path: string,
			base: string,
			range?: { start?: string; end?: string },
		): URL => {
			const url = new URL(`/counter/${encodeURIComponent(path)}.json`, base);
			if (range?.start) url.searchParams.set("start", range.start);
			if (range?.end) url.searchParams.set("end", range.end);
			return url;
		};

		const extractNumber = (values: unknown[]): number | null => {
			for (const v of values) {
				const parsed = normalizeNumber(v);
				if (parsed != null) return parsed;
			}
			return null;
		};

		// ===== Providers =====
		const fetchUmami = async (): Promise<{ recent: number; total: number }> => {
			if (!umamiStatsUrl) {
				throw new Error("Missing Umami stats URL.");
			}

			const u = new URL(umamiStatsUrl);
			u.searchParams.set("days", String(rangeDays));
			u.searchParams.set("t", String(Date.now())); // 필요 없으면 삭제 가능

			const res = await fetch(u.toString(), { cache: "no-store" });
			if (!res.ok) throw new Error(`Umami stats responded with ${res.status}`);

			const data: unknown = await res.json();
			const recent = normalizeNumber((data as any)?.recent) ?? 0;
			const total = normalizeNumber((data as any)?.total) ?? 0;

			return { recent, total };
		};

		const fetchGoatcounter = async (): Promise<{ recent: number | null; total: number | null }> => {
			if (!goatcounterBase) {
				throw new Error("Missing GoatCounter configuration.");
			}

			const today = formatKstDate(new Date());
			const tomorrow = addDaysYmd(today, 1);

			const [dailyResponse, totalResponse] = await Promise.all([
				fetch(
					buildGoatcounterUrl(goatcounterPath, goatcounterBase, {
						start: today,
						end: tomorrow,
					}).toString(),
				),
				fetch(buildGoatcounterUrl(goatcounterPath, goatcounterBase).toString()),
			]);

			if (!dailyResponse.ok) {
				throw new Error(`GoatCounter daily responded with ${dailyResponse.status}`);
			}
			if (!totalResponse.ok) {
				throw new Error(`GoatCounter total responded with ${totalResponse.status}`);
			}

			const dailyData: unknown = await dailyResponse.json();
			const totalData: unknown = await totalResponse.json();

			const recent = extractNumber([
				(dailyData as any)?.count,
				(dailyData as any)?.hits,
				(dailyData as any)?.views,
				(dailyData as any)?.total,
			]);

			const total = extractNumber([
				(totalData as any)?.count,
				(totalData as any)?.hits,
				(totalData as any)?.views,
				(totalData as any)?.total,
			]);

			return { recent, total };
		};

		const load = async (): Promise<void> => {
			try {
				if (provider !== "umami" && provider !== "goatcounter") {
					setStatus(statusNotConfigured);
					setCounts(null, null);
					return;
				}

				setStatus(statusLoading);

				let result: { recent: number | null; total: number | null } | null = null;

				if (provider === "umami") {
					const r = await fetchUmami();
					result = { recent: r.recent, total: r.total };
				} else if (provider === "goatcounter") {
					result = await fetchGoatcounter();
				}

				if (!result || (result.recent == null && result.total == null)) {
					throw new Error("Visitor count not available.");
				}

				setCounts(result.recent, result.total);
				setStatus("");
			} catch (e) {
				console.error("[VisitorCounter]", e);
				setCounts(null, null);
				setStatus(statusUnavailable);
			}
		};

		load();
	})();
</script>
